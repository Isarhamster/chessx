#include "output.h"

QMap <OutputType, Output*> Output::m_formats;
QMap <OutputType,QString> Output::m_outputMap;

Output::Output(OutputType output)
{
   m_outputType = output;
   m_variationIndentLevel = 5;
   m_variationIndentSize = 3;
   m_commentIndentOption = OnlyMainline;
   m_columnStyle = false;
   m_whiteColumnSpace = " ";
   m_blackColumnSpace = " ";
   initialize();
  
}

void Output::initialize()
{
   m_variationIndentStr = "";
   setMarkupTag(MarkupNoFormat,"","");
   if (m_outputType == OutputPgn) {
      m_header = "";
      m_footer = "";
      setMarkupTag(MarkupHeaderBlock,"","");
      setMarkupTag(MarkupNotationBlock,"",""); 
      setMarkupTag(MarkupResult,"","");
      setMarkupTag(MarkupMainLineMove,"","");
      setMarkupTag(MarkupVariationMove,"","");
      setMarkupTag(MarkupMainLine,"","");
      setMarkupTag(MarkupVariationInline,"","");
      setMarkupTag(MarkupVariationIndent,"\n   ","\n");
      setMarkupTag(MarkupNag,"","");
      setMarkupTag(MarkupAnnotationInline,"{","}");
      setMarkupTag(MarkupAnnotationIndent,"\n   {","}\n");
      setMarkupTag(MarkupHeaderLine,"[","]\n");
      setMarkupTag(MarkupHeaderTagName,"","");
      setMarkupTag(MarkupHeaderTagValue,"\"","\"");
      setMarkupTag(MarkupWhiteTag,"","");
      setMarkupTag(MarkupBlackTag,"","");
      setMarkupTag(MarkupEventTag,"","");
      setMarkupTag(MarkupDateTag,"","");
      setMarkupTag(MarkupSiteTag,"","");
      setMarkupTag(MarkupResultTag,"","");
      setMarkupTag(MarkupRoundTag,"","");
      for (int i = 0;i < m_variationIndentSize;i++) {
         m_variationIndentStr += " ";
      }
      m_newlineChar = "\n";
   } else if (m_outputType == OutputHtml) {
      m_header = "<html><head><title>ChessX HTML Output</title><style>\n";
      m_header += "A:link, A:visited { text-decoration: none }\n";
      m_header += "A:active { text-decoration: underline }\n";
      m_header += ".mainline {font-weight: bold; color: black}\n";
      m_header += ".variation-inline {font-weight: normal; color: blue}\n";
      m_header += ".variation-indent {margin-left: 30; font-weight: normal; color: blue}\n";
      m_header += ".comment-inline {font-weight: normal; text-decoration: none; color: green; font-style: normal}\n";
      m_header += ".comment-indent {margin-left: 30; font-weight: normal; text-decoration: none; color: green; font-style: normal}\n";
      m_header += ".nag {font-weight: normal; text-decoration: none; color: red; font-style: normal\n";
      m_header += "</style></head><body>\n";
      m_footer = "</body></html>\n";
      setMarkupTag(MarkupHeaderBlock,"","<br>\n");
      setMarkupTag(MarkupNotationBlock,"",""); 
      setMarkupTag(MarkupResult,"","");
      setMarkupTag(MarkupMainLineMove,"","");
      setMarkupTag(MarkupVariationMove,"","");
      setMarkupTag(MarkupMainLine,"<div class=\"mainline\">","</div>\n");
      setMarkupTag(MarkupVariationInline,"<span class=\"variation-inline\">","</span>\n");
      setMarkupTag(MarkupVariationIndent,"<div class=\"variation-indent\">","</div>\n");
      setMarkupTag(MarkupNag,"<span class=\"nag\">","</span>\n");
      setMarkupTag(MarkupColumnStyleMove,"<td width=50%>","\n");
      setMarkupTag(MarkupColumnStyleRow,"<tr class=\"mainline\">","\n");
      setMarkupTag(MarkupColumnStyleMainline,"<table border=0 width=50%>","</table>\n");
      setMarkupTag(MarkupAnnotationInline,"<span class=\"comment-inline\">","</span>\n");
      setMarkupTag(MarkupAnnotationIndent,"<div class=\"comment-indent\">","</div>\n");
      setMarkupTag(MarkupHeaderLine,"<font color=\"blue\">[","]</font><br>\n");
      setMarkupTag(MarkupHeaderTagName,"","");
      setMarkupTag(MarkupHeaderTagValue,"\"","\"");
      setMarkupTag(MarkupWhiteTag,"","");
      setMarkupTag(MarkupBlackTag,"","");
      setMarkupTag(MarkupEventTag,"","");
      setMarkupTag(MarkupDateTag,"","");
      setMarkupTag(MarkupSiteTag,"","");
      setMarkupTag(MarkupResultTag,"","");
      setMarkupTag(MarkupRoundTag,"","");
      for (int i = 0;i < m_variationIndentSize;i++) {
         m_variationIndentStr += "&nbsp;";
      }
      m_newlineChar = "<br>\n";
   } else if (m_outputType == OutputLatex) {
      m_header = "\\documentclass[10pt,twocolumn]{article}\n";
      m_header += "% This is a LaTeX file generated by Scid.\n";
      m_header += "% You must have the \"chess12\" package installed to typeset this file.\n\n";
      m_header += "\\usepackage{times}\n";
      m_header += "\\usepackage{a4wide}\n";
      m_header += "\\usepackage{chess}\n";
      m_header += "\\usepackage[T1]{fontenc}\n\n";
      m_header += "\\setlength{\\columnsep}{7mm}\n";
      m_header += "\\setlength{\\parindent}{0pt}\n\n";
      m_header += "% Macros for variations and diagrams:\n";
      m_header += "\\newenvironment{variation}{\\begin{quote}}{\\end{quote}}\n";
      m_header += "\\newenvironment{diagram}{\\begin{nochess}}{$$\\showboard$$\\end{nochess}}\n\n";
      m_header += "\\begin{document}\n";
      m_footer = "\\begin{center} \\hrule \\end{center}\n\n";
      m_footer += "\\end{document}\n";
      setMarkupTag(MarkupHeaderBlock,"{\\bf\n","\\\\ \n}");
      setMarkupTag(MarkupNotationBlock,"\\begin{chess}{\\bf\n","}\\end{chess}"); 
      setMarkupTag(MarkupResult,"{\\bf ","}");
      setMarkupTag(MarkupMainLineMove,"","");
      setMarkupTag(MarkupVariationMove,"","");
      setMarkupTag(MarkupMainLine,"","");
      setMarkupTag(MarkupVariationInline,"\\begin{variation}","\\end{variation}");
      setMarkupTag(MarkupVariationIndent,"\\begin{variation}","\\end{variation}");
      setMarkupTag(MarkupNag,"","");
      setMarkupTag(MarkupColumnStyleMove,"","");
      setMarkupTag(MarkupColumnStyleRow,"","");
      setMarkupTag(MarkupColumnStyleMainline,"","");
      setMarkupTag(MarkupAnnotationInline,"\\begin{nochess}{\\rm ","}\\end{nochess}");
      setMarkupTag(MarkupAnnotationIndent,"\\begin{nochess}{\\rm ","}\\end{nochess}");
      setMarkupTag(MarkupHeaderLine,""," \\\\");
      setMarkupTag(MarkupHeaderTagName,"","");
      setMarkupTag(MarkupHeaderTagValue,"\"","\"");
      setMarkupTag(MarkupWhiteTag,"","");
      setMarkupTag(MarkupBlackTag,"","");
      setMarkupTag(MarkupEventTag,"","");
      setMarkupTag(MarkupDateTag,"","");
      setMarkupTag(MarkupSiteTag,"","");
      setMarkupTag(MarkupResultTag,"","");
      setMarkupTag(MarkupRoundTag,"","");
      for (int i = 0;i < m_variationIndentSize;i++) {
         m_variationIndentStr += " ";
      }
      m_newlineChar = "\n";
   } else if (m_outputType == OutputNotationWidget) {
      m_header = "<html><head><title>ChessX HTML Output</title><style>\n";
      m_header += "A:link, A:visited { text-decoration: none }\n";
      m_header += "A:active { text-decoration: underline }\n";
      m_header += ".mainline {font-weight: bold; color: black}\n";
      m_header += ".variation-inline {font-weight: normal; color: blue}\n";
      m_header += ".variation-indent {margin-left: 30; font-weight: normal; color: blue}\n";
      m_header += ".comment-inline {font-weight: normal; text-decoration: none; color: green; font-style: normal}\n";
      m_header += ".comment-indent {margin-left: 30; font-weight: normal; text-decoration: none; color: green; font-style: normal}\n";
      m_header += ".nag {font-weight: normal; text-decoration: none; color: red; font-style: normal\n";
      m_header += "</style></head><body>\n";
      m_footer = "</body></html>\n";
      setMarkupTag(MarkupHeaderBlock,"","<br>\n");
      setMarkupTag(MarkupNotationBlock,"",""); 
      setMarkupTag(MarkupResult,"","");
      setMarkupTag(MarkupMainLineMove,"<a class=\"mainline\" href=\"move%1\">","</a>");
      setMarkupTag(MarkupVariationMove,"<a class=\"variation\" href=\"move%1\">","</a>");
      setMarkupTag(MarkupMainLine,"<div class=\"mainline\">","</div>\n");
      setMarkupTag(MarkupVariationInline,"<span class=\"variation-inline\">","</span>\n");
      setMarkupTag(MarkupVariationIndent,"<div class=\"variation-indent\">","</div>\n");
      setMarkupTag(MarkupNag,"<span class=\"nag\">","</span>\n");
      setMarkupTag(MarkupColumnStyleMove,"<td width=50%>","\n");
      setMarkupTag(MarkupColumnStyleRow,"<tr class=\"mainline\">","\n");
      setMarkupTag(MarkupColumnStyleMainline,"<table border=0 width=50%>","</table>\n");
      setMarkupTag(MarkupAnnotationInline,"<a class=\"comment-inline\" href=\"cmt%2\">","</a>\n");
      setMarkupTag(MarkupAnnotationIndent,"<div class=\"\"><a class=\"comment-indent\" href=\"cmt%2\">","</a></div>\n");
      setMarkupTag(MarkupHeaderLine,"<font color=\"blue\">[","]</font><br>\n");
      setMarkupTag(MarkupHeaderTagName,"","");
      setMarkupTag(MarkupHeaderTagValue,"\"","\"");
      setMarkupTag(MarkupWhiteTag,"","");
      setMarkupTag(MarkupBlackTag,"","");
      setMarkupTag(MarkupEventTag,"","");
      setMarkupTag(MarkupDateTag,"","");
      setMarkupTag(MarkupSiteTag,"","");
      setMarkupTag(MarkupResultTag,"","");
      setMarkupTag(MarkupRoundTag,"","");

      for (int i = 0;i < m_variationIndentSize;i++) {
         m_variationIndentStr += "&nbsp;";
      }
      m_newlineChar = "<br>\n";
   }
}

void Output::createObjects()
{
   m_outputMap.clear();
   m_outputMap[OutputHtml] = "Html Output";
   m_outputMap[OutputPgn] = "Pgn Output";
   m_outputMap[OutputLatex] = "Latex Output";
   m_outputMap[OutputNotationWidget] = "Notation Widget Output";


   QMap<OutputType,QString>::iterator it;
   for ( it = m_outputMap.begin(); it != m_outputMap.end(); ++it ) {
      m_formats[it.key()] = new Output(it.key()); //output;
   }

}

QMap<OutputType,QString>& Output::getFormats()
{
   return m_outputMap;
}

void Output::writeMove(int variation)
{

   if (m_columnStyle && (m_currentVariationLevel == 0)) {
      // *** If the column style option is set and it's a mainline move
      // *** some special markup is required
      if (m_game->board().toMove() == White) {
         // ** If it is white to move, start a new row
         m_output += m_startTagMap[MarkupColumnStyleRow] + m_startTagMap[MarkupColumnStyleMove];
         if (m_currentVariationLevel > 0) {
            m_output += m_startTagMap[MarkupVariationMove];
         } else {
            m_output += m_startTagMap[MarkupMainLineMove];
         }
         m_output += QString::number((m_game->ply()+2)/2) + ".";
      } else if (m_dirtyBlack) {
         // ** If it is black to move and we need the ... then add a extra
         // ** column before adding the column for the move
         m_output += m_startTagMap[MarkupColumnStyleRow] + m_startTagMap[MarkupColumnStyleMove];
         m_output += QString::number((m_game->ply()+2)/2) + ". ...";
         m_output += m_startTagMap[MarkupColumnStyleMove];
         if (m_currentVariationLevel > 0) {
            m_output += m_startTagMap[MarkupVariationMove];
         } else {
            m_output += m_startTagMap[MarkupMainLineMove];
         }
      } else {
         // ** If it is black to move and we don't need the ... 
         m_output += m_startTagMap[MarkupColumnStyleMove];
         if (m_currentVariationLevel > 0) {
            m_output += m_startTagMap[MarkupVariationMove];
         } else {
            m_output += m_startTagMap[MarkupMainLineMove];
         }
      }  
   } else {
      // *** Markup for the move
      if (m_currentVariationLevel > 0) {
         m_output += m_startTagMap[MarkupVariationMove];
      } else {
         m_output += m_startTagMap[MarkupMainLineMove];
      }
      // *** Write the move number
      if (m_game->board().toMove() == White) {
         m_output += QString::number((m_game->ply()+2)/2) + ".";
      } else if (m_dirtyBlack) {
         m_output += QString::number((m_game->ply()+2)/2) + "...";
      }
   }
   m_dirtyBlack = false;

   // *** Write the actual move
   m_output += m_game->moveToSan(Game::MoveOnly,variation) + " ";
   // *** End the markup for the move
   if (m_currentVariationLevel > 0) {
      m_output += m_endTagMap[MarkupVariationMove];
   } else {
      m_output += m_endTagMap[MarkupMainLineMove];
   }
   // *** Write the nags if there are any
   if(m_game->nags(variation).count() > 0) {
      m_output += m_startTagMap[MarkupNag] + m_game->nags(variation).toPGNString() + " " + m_endTagMap[MarkupNag];
   }
   // *** Write the annotations if any
   if (m_game->annotation(variation) != QString::null) {
      if (m_columnStyle && (m_currentVariationLevel == 0)) {
         m_output += m_endTagMap[MarkupColumnStyleMainline];
      }
      if ((m_commentIndentOption == Always) || ((m_commentIndentOption == OnlyMainline) 
               && (m_currentVariationLevel == 0))) {
         m_output += m_startTagMap[MarkupAnnotationIndent] + 
                     m_game->annotation(variation) + " " +
                     m_endTagMap[MarkupAnnotationIndent];
      } else {
         m_output += m_startTagMap[MarkupAnnotationInline] + 
                     m_game->annotation(variation) + " " +
                     m_endTagMap[MarkupAnnotationInline];
      }
      if (m_columnStyle && (m_currentVariationLevel == 0)) {
         m_output += m_startTagMap[MarkupColumnStyleMainline];
      }
      m_dirtyBlack = true;
   }
   // *** Substitute %1 and %2 if present with the move node number
   if ((m_output.find("%1")>=0) && (m_output.find("%2")>=0)) {
      QString mvno;
      mvno = mvno.sprintf("%03d",m_game->moveId());
      m_output = m_output.arg(mvno).arg(mvno);
   } else if (m_output.find("%1")>=0) {
      QString mvno;
      mvno = mvno.sprintf("%03d",m_game->moveId());
      m_output = m_output.arg(mvno);
   }
}
void Output::writeNewlineIndent()
{
   int indentLevel;
   if (m_currentVariationLevel > m_variationIndentLevel) {
      indentLevel = m_variationIndentLevel;
   } else {
      indentLevel = m_currentVariationLevel;
   }
   if (m_variationIndentLevel >= 0) {
      m_output += m_newlineChar;
      for (int i = 0;i < indentLevel;++i) {
         m_output += m_variationIndentStr;
      }
   }
}
void Output::writeVariation()
{
	while(!m_game->atEnd()) {		
      // *** Writes move in the current variation
      writeMove();
      if (m_game->variationCount() > 1) {
         for (int i = 1;i < m_game->variationCount();++i) {
            m_currentVariationLevel += 1;
            if (m_columnStyle && (m_currentVariationLevel == 1)) {
               m_output += m_endTagMap[MarkupColumnStyleMainline];
            }
            if (m_currentVariationLevel <= m_variationIndentLevel) {
               m_output += m_startTagMap[MarkupVariationIndent];
            } else {
               m_output += m_startTagMap[MarkupVariationInline];
            }

            m_output +=  "(";
            m_dirtyBlack = true;
				
            // *** Writes the first move in variation i
            writeMove(i);
				
            // *** Enter variation i, and write the rest of the moves
				m_game->enterVariation(i);
				writeVariation();
				m_game->exitVariation();
				
            // *** End the variation
            m_output += ")";
            if (m_currentVariationLevel <= m_variationIndentLevel) {
               m_output += m_endTagMap[MarkupVariationIndent];
            } else {
               m_output += m_endTagMap[MarkupVariationInline];
            }
            m_currentVariationLevel -= 1;
            if (m_columnStyle && (m_currentVariationLevel == 0)) {
               m_output += m_startTagMap[MarkupColumnStyleMainline];
            }
            m_dirtyBlack = true;
			}
		}
		m_game->forward();
	}
}
   
void Output::writeTag(QString tagName)
{
   MarkupType specialTag = MarkupNoFormat;
   if (tagName == "Event") {
      specialTag = MarkupEventTag;
   } else if (tagName == "Site") {
      specialTag = MarkupSiteTag;
   } else if (tagName == "Round") {
      specialTag = MarkupRoundTag;
   } else if (tagName == "Date") {
      specialTag = MarkupDateTag;
   } else if (tagName == "White") {
      specialTag = MarkupWhiteTag;
   } else if (tagName == "Black") {
      specialTag = MarkupBlackTag;
   } else if (tagName == "Result") {
      specialTag = MarkupResultTag;
   }

   m_output += m_startTagMap[MarkupHeaderLine] +
               m_startTagMap[specialTag] +
               m_startTagMap[MarkupHeaderTagName] +
               tagName + " " +
               m_endTagMap[MarkupHeaderTagName] +
               m_startTagMap[MarkupHeaderTagValue] +
               m_game->tag(tagName) +
               m_endTagMap[MarkupHeaderTagValue] +
               m_endTagMap[specialTag] +
               m_endTagMap[MarkupHeaderLine];
   //writeNewlineIndent(); //fine

}

QString Output::output(Game* game)
{

   m_game = game;
   m_dirtyBlack = false;
   m_currentVariationLevel = 0;

   m_output = m_header;
   m_output += m_startTagMap[MarkupHeaderBlock];
   writeTag("Event");
   writeTag("Site");
   writeTag("Date");
   writeTag("Round");
   writeTag("White");
   writeTag("Black");
   writeTag("Result");
   m_output += m_endTagMap[MarkupHeaderBlock];
   //writeNewlineIndent(); //fine 
   m_game->moveToStart();
   m_output += m_startTagMap[MarkupNotationBlock];
   m_output += m_startTagMap[MarkupMainLine];
   if (m_columnStyle) {
      m_output += m_startTagMap[MarkupColumnStyleMainline];
   }
   writeVariation();
   if (m_columnStyle) {
      m_output += m_endTagMap[MarkupColumnStyleMainline];
   }
   m_output += m_endTagMap[MarkupMainLine];
   m_output += m_endTagMap[MarkupNotationBlock];
   m_output += m_startTagMap[MarkupResult] + resultString(game->result()) + m_endTagMap[MarkupResult];
   m_output += m_footer;

   return m_output;
}

void Output::setMarkupTag (MarkupType type, const QString& startTag, const QString& endTag)
{
   m_startTagMap[type] = startTag;
   m_endTagMap[type] = endTag;
}
void Output::markupTag (MarkupType type , QString& startTag, QString& endTag)
{
   startTag = m_startTagMap[type];
   endTag = m_endTagMap[type];
}

void Output::setTextWidth(int textWidth)
{
   m_textWidth = textWidth;
}
int Output::textWidth()
{
   return m_textWidth;
}
void Output::setColumnStyle (bool columnStyle)
{
   m_columnStyle = columnStyle;
}
bool Output::columnStyle()
{
   return m_columnStyle;
}
void Output::setVariationIndentSize(int variationIndentSize)
{
   m_variationIndentSize = variationIndentSize;
}
int Output::variationIndentSize()
{
   return m_variationIndentSize;
}
void Output::setVariationIndentLevel(int variationIndentLevel)
{
   m_variationIndentLevel = variationIndentLevel;
}
int Output::variationIndentLevel()
{
   return m_variationIndentLevel;
}
void Output::setCommentIndentOption(CommentIndentOption option)
{
   m_commentIndentOption = option;
}
CommentIndentOption Output::commentIndentOption()
{
   return m_commentIndentOption;
}
